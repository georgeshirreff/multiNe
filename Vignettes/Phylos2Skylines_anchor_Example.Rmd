---
title: "Using Phylos2Skylines_anchor"
output: html_document
---

This vignette describes the functions in the multiNe package which allow coalescent analysis of phylogenetic objects, along with auxiliary functions such as plotting. The basic coalescent analysis extends that found in the ape package but allows for phylogenies with heterochronous dated tips. Coalescent theory states that the rate at which the lineages in a phylogeny coalesce is inversely proportional to the effective population size. 

The most important function for this is 'Phylos2Skylines_anchor'. This takes as its first argument a multiPhylo object, which is effectively a list of phylo objects, each of which is a tree. This type of object is the typical result of reading in the output from a program which does Bayesian inference, such as BEAST or MrBayes.

Alternatively, a multiPhylo object can be simulated using rmtree in the ape package. For future use, write these into a nexus file. 

Start by loading the multiNe package, and making an example trees file. This can be written to a nexus file. 

```{r}
require(multiNe)
require(ape)
trees<-rmtree(N = 10,n=10,tip.label=paste("t",1:10,"_",1:10,sep=""))
write.nexus(trees,file="my_tree_file.nexus")
```

You can access your trees in one of two ways. Either you can get the function itself to read them in for you. 

```{r}
Phylos2Skylines_anchor(trees = "my_tree_file.nexus",file_type="nex",output_type="list")
```

Or you can read them into R beforehand as a multiPhylo object e.g. using 

```{r}
trees<-read.nexus(file="my_tree_file.nexus") 
Phylos2Skylines_anchor(trees,output_type="list")
```

The default output_type="list" will produce a list, one for each tree, of skyline objects

The output_type="matrices" will produce two tables, with the columns of the table representing each tree, one (time_mat) with the end times of each coalescent interval, and one (pop_mat) with the effective population size during that interval, and each row representing a coalescent event in that tree. 

```{r}
Phylos2Skylines_anchor(trees,output_type="matrices")
```

The output_type="master" will produce a single master table, with the columns of the table representing each tree, one (time_mat) with the end times of each coalescent interval, and one (pop_mat) with the effective population size during that interval, and each row representing a coalescent event in one of the trees. 

```{r}
Phylos2Skylines_anchor(trees,output_type = "master")
```

The most functional option, output_type="conf.int.plot" will do the above and plot a figure with the median skyline and its confidence intervals. It will also return a matrix with 4 columns representing the time, median, lower and upper confidence intervals, respectively. 

```{r}
conf_int_obj<-Phylos2Skylines_anchor(trees,output_type = "conf.int.plot")
```

Finally, the output_type="conf.int" returns this object, but without plotting. 

```{r}
conf_int_obj<-Phylos2Skylines_anchor(trees,output_type = "conf.int")
```

Assuming that the set of trees is raw posterior output, you will presumably want to discard some proportion of the early trees, and this is specified with burninfrac. This can be assessed by examining the accompanying log file in Tracer. 

```{r}
conf_int_obj<-Phylos2Skylines_anchor(trees,output_type = "conf.int.plot",burninfrac=0.1)
```

If the branch lengths of the trees are in substitutions per site, and you want the skyline plot to be in units of time, you may wish to scale them according to a clock rate, which is specified with "scaling".

```{r}
conf_int_obj<-Phylos2Skylines_anchor(trees,output_type = "conf.int.plot",burninfrac=0.1,scaling=0.011)
```

If the names of the tips of the tree contain the date, then the skyline can be directly fixed to those dates. This is done by setting fixToDate=TRUE, and then by specifying a function which will return the dates as numeric values. In this example, this assumes that the tips are labelled as follows, as an example: t1_2001.2, t2_2005.3, t3_2009.98 etc. 

```{r}
Date_FUN = function(label) as.numeric(gsub(".*_([.0-9]+)","\\1",label))
Date_FUN(trees[[1]]$tip.label) #this should return a vector of tip dates
conf_int_obj<-Phylos2Skylines_anchor(trees,output_type = "conf.int.plot",fixToDate = T,Date_FUN = Date_FUN)
```

If the multiPhylo object or the file containing the trees is very large, it may be very time-consuming to read in and perform the coalescent analysis on them. The argument max_trees allows only a limited number to be used, which is by default 1000. The trees are then selected at regular intervals from the multiPhylo object. 

```{r}
Phylos2Skylines_anchor(trees,output_type = "conf.int.plot")
Phylos2Skylines_anchor(trees,output_type = "conf.int.plot",max.trees=5)
```

Skyline data are usually presented by a step function, consistenting of only vertical and horizontal lines, implying that for a given period the best estimate for the effective population size is a certain value. For some analyses, it may be preferred that points on the graph are joined by straight sloping lines, implying that the effective population size during this period changes in a regular fashion. 

```{r}
Phylos2Skylines_anchor(trees,output_type = "conf.int.plot",plot_type="step")
Phylos2Skylines_anchor(trees,output_type = "conf.int.plot",plot_type="linear")
```

Another useful plotting feature is the smoothing capability when using output_type="conf.int.plot". If the value 'epsilon' is specified, this means that no time interval in the plot will be shorter than that value (default epsilon=0). This is achieved by combining neighbouring intervals until the condition is met. 

```{r}
Phylos2Skylines_anchor(trees,output_type = "conf.int.plot",epsilon=0)
Phylos2Skylines_anchor(trees,output_type = "conf.int.plot",epsilon=0.01)
Phylos2Skylines_anchor(trees,output_type = "conf.int.plot",epsilon=0.05)
Phylos2Skylines_anchor(trees,output_type = "conf.int.plot",epsilon=0.1)
Phylos2Skylines_anchor(trees,output_type = "conf.int.plot",epsilon=0.5)
```

===============================================================

An additional useful feature of this function is getNodeAges. This returns a vector with the ages of each of the tips, root and internal nodes (in that order). The tip ages in the vector are labelled with the name of the tip; the root node is named "root"; and the internal nodes are named <NA>. The argument 'from_past' determines whether the ages are relative to the root or the youngest tip: the default is the latter. 

```{r}
getNodeAges(trees[[1]],from_past=F)
getNodeAges(trees[[1]],from_past=T)
```
